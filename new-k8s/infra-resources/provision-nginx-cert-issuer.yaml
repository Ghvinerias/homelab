---
- name: Deploy Kubernetes resources with Helm and kubectl
  hosts: localhost
  gather_facts: false
  connection: local
  become: false
  vars:
    kubeconfig: "{{ lookup('env', 'KUBECONFIG') | default('~/.kube/config', true) }}"
    kube_context: "" # Set to your context if needed, else leave blank
    infisical_host_api: "https://infisical.infra.slick.ge/api"
    identity_id: "998c1306-87ff-4b1e-9225-2f82ef8d5fff"
    project_slug: "infra-resources-b-ou-q"
    env_slug: "homelablocal"
    secrets_path: "/"
    cloudflare_email: "ghvinerias@gmail.com"
    letsencrypt_email: "ghvineriaa@gmail.com"
    cert_issuer: "cloudflare-dns01" # Options: "cloudflare-dns01" or "http01"

  tasks:
    - name: Ensure ingress-nginx Helm repo is present
      kubernetes.core.helm_repository:
        name: ingress-nginx
        repo_url: https://kubernetes.github.io/ingress-nginx

    - name: Ensure cert-manager (jetstack) Helm repo is present
      kubernetes.core.helm_repository:
        name: jetstack
        repo_url: https://charts.jetstack.io

    - name: Deploy ingress-nginx via Helm
      kubernetes.core.helm:
        name: ingress-nginx
        chart_ref: ingress-nginx/ingress-nginx
        release_namespace: ingress-nginx
        create_namespace: true
        values: 
          controller:
            hostNetwork: true
            dnsPolicy: ClusterFirstWithHostNet
            kind: DaemonSet
            service:
              type: ClusterIP
            admissionWebhooks:
              enabled: false
            tolerations:
              # Allow scheduling on control-plane nodes (new taint)
              - key: "node-role.kubernetes.io/control-plane"
                operator: "Exists"
                effect: "NoSchedule"
              # Backward-compat for older taint name
              - key: "node-role.kubernetes.io/master"
                operator: "Exists"
                effect: "NoSchedule"
          # Uncomment to enable monitoring of ingress-nginx, but prometheus needs to be provisioned first
          # See k8s/gp/README.md for instructions
          metrics:
            enabled: true
            service:
              enabled: true
            serviceMonitor:
              enabled: true
              namespace: monitoring
              scrapeInterval: 30s
              # No selector labels required since Prometheus in kube-prometheus-stack is set to scrape all ServiceMonitors
              additionalLabels: {}
          
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
        wait: true
        atomic: true
        update_repo_cache: true

    - name: Deploy cert-manager via Helm (with CRDs)
      kubernetes.core.helm:
        name: cert-manager
        chart_ref: jetstack/cert-manager
        release_namespace: cert-manager
        create_namespace: true
        set_values:
          - value: crds.enabled=true
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
        wait: true
        atomic: true
        update_repo_cache: true

    - name: Wait for cert-manager CRDs to be available
      kubernetes.core.k8s_info:
        api_version: apiextensions.k8s.io/v1
        kind: CustomResourceDefinition
        name: clusterissuers.cert-manager.io
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
      register: crd_info
      retries: 10
      delay: 10
      until: crd_info.resources | length > 0

    - name: Create InfisicalSecret for Cloudflare API token
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: secrets.infisical.com/v1alpha1
          kind: InfisicalSecret
          metadata:
            name: cloudflare-api-token
            namespace: cert-manager
          spec:
            hostAPI: "{{ infisical_host_api }}"
            resyncInterval: 10
            authentication:
              kubernetesAuth:
                identityId: "{{ identity_id }}"
                serviceAccountRef:
                  name: infisical-service-account
                  namespace: infisical
                secretsScope:
                  envSlug: "{{ env_slug }}"
                  projectSlug: "{{ project_slug }}"
                  secretsPath: "{{ secrets_path }}"
            managedKubeSecretReferences:
              - secretName: cloudflare-api-token-secret
                secretNamespace: cert-manager
                creationPolicy: Orphan
                template:
                  includeAllSecrets: false
                  data:
                    api-token: "{{ '{{' }} .CLOUDFLARE_API_TOKEN.Value {{ '}}' }}"
      when: cert_issuer == "cloudflare-dns01"

    - name: Wait for cloudflare-api-token-secret Secret to be created by Infisical
      kubernetes.core.k8s_info:
        kind: Secret
        name: cloudflare-api-token-secret
        namespace: cert-manager
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
      register: cloudflare_token_secret
      until: cloudflare_token_secret.resources | length > 0
      retries: 30
      delay: 10
      failed_when: cloudflare_token_secret.resources | length == 0
      when: cert_issuer == "cloudflare-dns01"

    - name: Apply ClusterIssuer YAML for HTTP01 challenge
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: "{{ letsencrypt_email }}"
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
                - http01:
                    ingress:
                      class: nginx
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
      when: cert_issuer == "http01"

    - name: Apply ClusterIssuer YAML for Cloudflare DNS01 challenge
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: "{{ letsencrypt_email }}"
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
                - dns01:
                    cloudflare:
                      email: "{{ cloudflare_email }}"
                      apiTokenSecretRef:
                        name: cloudflare-api-token-secret
                        key: api-token
        kubeconfig: "{{ kubeconfig }}"
        context: "{{ kube_context if kube_context else omit }}"
      when: cert_issuer == "cloudflare-dns01"
